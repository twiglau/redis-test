# 取舍和选择

## 持久化的作用

- 什么是持久化
  redis 所有数据保持在内存中，对数据的更新将异步地保存在磁盘上。
- 持久化方式

1. 快照： MySQL Dump, Redis RDB
2. 写日志： MySQL BinLog, Hbase HLog, Redis AOF

## RDB -方式

1. 什么是 RDB

```lua
# 快照
redis【内存】 - - 创建 - - > RDB文件（二进制）【硬盘当中】
                              |
redis < - - 启动载入 - - - - - -
```

2. 触发机制 - 主要三种方式

- save 命令(同步)
  > 数据量大时，会阻塞【单线程中执行，并且是同步的命令】
  > 文件策略： 如存在老的 RDB 文件，新的替换老的文件。
  > 复杂度： O(N)

```sh
> save
"OK"
```

```lua
client - - save - - > redis - - 创建 - - > RDB文件(二进制)
```

- bgsave 命令(异步)

```sh
> bgsave
"Background saving started"
```

> 生成过程
>
> Linux 的 fork 函数，生成 子进程。让这个子进程，去完成 RDB 的生成。

```lua
client - - 1. bgsave - - > redis
                    2.fork()| | 4. bgsave successfully
                            | |
                            redis - 3. createRDB - > RDB文件（二进制）
```

```lua
命令             save               bgsave
IO类型           同步                异步
阻塞？            是                 是（阻塞发生在fork)
复杂度            O(n)               O(n)
优点             不会消耗额外内存      不阻塞客户端命令
缺点             阻塞客户端命令        需要fork,消耗内存
```

- 自动 (bgsave)

```conf
配置         seconds          changes
save         900               1
save         300               10
save         60                10000

# 名字
dbfilename   dump.rdb
# 存放目录
dir ./
# 如果发生错误，是否停止写入
stop-writes-on-bgsave-error yes
# 是否采用压缩格式
rdbcompression yes
# 是否检查数量
rdbchecksum yes
```

- 最佳配置

```conf
# 增加端口，识别信息
dbfilename dump-${port}.rdb
# 不存在根目录，存放在比较大的磁盘路径上
dir /bigdiskpath
# 如果发生错误，是否停止写入
stop-writes-on-bgsave-error yes
# 是否采用压缩格式
rdbcompression yes
# 是否检查数量
rdbchecksum yes
```

3. 触发机制 - 不容忽视方式

- 全量复制：没有主动执行命令（save,bgsave)怎么还有 rdb 文件呢？

  > 主从之间进行全量复制时，会主动生成 rdb 文件。

- debug reload: 进行 debug 级别的重启

  > 不会将数据清空进行重启

- shutdown

  > shutdown save 会执行 rdb 文件的生成。

4. 测试效果

```sh
# 根据配置文件 启动 redis
redis-cli redis-6370.conf

# 检查redis当前使用情况
info memory

# 检查 grep -v 排除某些内容: 不看redis-cli 客户端，不看grep
ps -ef|grep redis- |grep -v "redis-cli" |grep -v "grep"

# 查看最新日志
tail -f 6379.log

# 关闭
redis-cli shutdown
```

## AOF -方式

1. RDB 现存问题：耗时，耗性能； 不可控，丢失数据；

   > O(n)数据：Data dump to dis, 耗时
   > fork(): 消耗内存，copy-on-write 策略
   > Disk I/O: IO 性能

2. 什么是 AOF： 写日志
3. AOF 三种策略

- always
- everysec
- no(根据操作系统来决定的)

```lua
命令          always        everysec          no
 优点        不丢失数据      每秒一次fsync       不用管
                           丢1秒数据

 缺点       IO开销较大，一    丢1秒数据           不可用
           般的sata盘只有
           几百TPS
```

4. AOF 重写：把过期的，重复的，没有用的数据

- 作用：

1. 减少硬盘占用量
2. 加速恢复速度

- 重写实现两种方式

1. bgrewriteaof
2. AOF 重写配置

   - 配置项
     > `auto-aof-rewrite-min-size`: AOF 文件重写需要的尺寸
     > `auto-aof-rewrite-percentage`: AOF 文件增长率
   - 统计项
     > `aof_current_size`: AOF 当前尺寸（单位：字节）
     > `aof_base_size`: AOF 上次启动和重写的尺寸
   - 自动触发时机
     > `aof_current_size` > `auto-aof-rewrite-min-size` > `aof_current_size` - `aof_base_size`/`aof_base_size` > `auto-aof-rewrite-percentage`

3. AOF 重写流程

```lua
 bgrewriteaof
      | 1)
    父进程 < - - 5.1) 信号通知父进程 - - -
      | 2)                            |
     fork    - - - - - - - - - - -  子进程
3.1)  ||   3.2)                        | 4）
   - -|| - -
 aof_buf    aof_rewrite_buf - 5.2) - > 新 AOF 文件
   |                                     |
 旧AOF文件 < - - 5.3) - - - - - - - - - - -
```

4. AOF 配置

```conf
# 是否开启AOF
appendonly yes
# aof文件名
appendfilename "appendonly-${port}.aof"
# aof 重写策略
appendfsync  everysec
# 保存地址
dir /bigdiskpath
no-appendfsync-on-rewrite yes

```

5. 实验性质

```sh
# 从根目录 / 开始递归查找所有子目录
# -type f:  只匹配普通文件（排除目录，设备等).
# 2>/dev/null: 将标准错误（文件描述符2，例如“权限被拒绝”的错误信息） 重定向到 /dev/null
# 即屏蔽错误输出，使结果更干净。
find / -type f -name "redis.conf" 2>/dev/null

# 动态设置变量
config set appendonly yes
# 重启配置
config rewrite
```

## RDB 和 AOF 的抉择

- RDB 和 AOF 比较

```lua
命令           RDB          AOF
启动优先级       低           高
体积            小           大
恢复速度         快           慢
数据安全性       丢数据       根据策略决定
轻重            重           轻
```

- RDB 最佳策略
- AOF 最佳策略
- 最佳策略
