# api 使用

## 通用命令

1. keys: 所有键

```sh
keys *
keys he*
keys he[h-l]* # 第三位是 h 或 l
keys ph? # ?匹配一位字符
```

- keys 一般不再生产环境中使用
- 那应该怎么用？
  > 热备从节点
  > scan 命令

2. dbsize： 计算 key 的总数
3. exist key
4. del key [key1, ...]
5. expire key seconds

```sh
ttl key # 查看key剩余的过期时间
persist key # 去掉key的过期时间
```

6. type key ：返回 key 的类型

## 数据类型

### 内部编码

```lua
数据结构                 内部编码
string               raw,int,embstr
hash                 hashtable,ziplist
list                 linkedlist,ziplist
set                  hashtable,intset
zset                 skiplist,ziplist
```

- 单线程: 为什么快？

  > 纯内存
  > 非阻塞 IO
  > 避免线程切换和静态消耗

- 单线程：需要注意什么？
  > 一次只运行一条命令
  > 拒绝长（慢）命令：keys,flushall,flushdb,slow lua script, mutil/exec, operate big value(collection)
  > 其实不是单线程 fysnc file descriptor, close file descriptor

### 字符串类型

- 结构和命令
  key[字符串]：value[字符串，整型， 位图]

- 使用场景： 缓存，计数器，分布式锁 等。

- 练习

1. `incr key` #key 自增 1，如果 key 不存在，自增后 get(key)=1.
2. `decr key` #key 自减 1.
3. `incrby key n` # key 自增 n.
4. `decrby key n` # key 自减 n.

5. 如何缓存视频的基本信息？

```js
const videoRedisKey = prefix + vid;
let videoBasicInfo = redis.get(videoRedisKey);
if (videoBasicInfo === null) {
  videoBasicInfo = mysql.query(id);
  if (videoBasicInfo != null) {
    redis.set(videoRedisKey, JSON.stringify(videoBasicInfo));
  }
}
```

6. 实现分布式 id 生成器 ？ `incr id`

   > 有三个应用服务。三个每次获取（并发）的 id 都是自增，并且不会重复？

7. `set key value`: 不管 key 是否存在，都设置
8. `setnx key value` : key 不存在，才设置 (添加操作)
9. `set key value xx` : key 存在，才设置 (更新操作)
10. `mget mset`: 批量操作

- 内部编码
- 总结

11. `getset key newvalue`: set key newvalue 并返回旧的 value
12. `append key value`: 将 value 追加到旧的 value
13. `strlen key`: 返回字符串的长度（注意中文）

### 哈希类型

- 特点

1. `hget key field`: 获取 hash key 对应的 field 的 value
2. `hset key field value`: 设置 hash key 对应的 field 的 value
3. `hdel key field`: 删除 hash key 对应的 field 的 value

- 重要 API

4. `hexists key field`: 判断 hash key 是否有 field
5. `hlen key`: 获取 hash key field 的数量
6. `hmget, hmset`: 批量操作
7. `hgetall key`: 返回 hash key 对应所有的 field 和 value
8. `hvals key`: 返回 hash key 对应所有 field 的 value
9. `hkeys key`: 返回 hash key 对应所有 field

- 示例

1. 记录网站每个用户个人主页的访问量？

```sh
# 给用户信息中 pageview 增加 count
hincrby user:1:info pageview count
```

2. 缓存视频的基本信息（数据源在 mysql 中）伪代码

```js
const redisKey = redisPrefix + vid;
let hasMap = redis.hgetAll(redisKey);
let videoInfo = transferMapToVideo(hashMap);

if (videoInfo == null) {
  videoInfo = mysql.get(id);
  if (videoInfo != null) {
    redis.hmset(rediskey, transferVideoToMap(videoInfo));
  }
}

return videoInfo;
```

- hash vs string
- 总结

10. `hsetnx key field value`: 设置 hash key 对应的 field 的 value(如 field 已经存在，则失败)
11. `hincrby key field intCounter`: hash key 对应的 field 的 value 自增 intCounter
12. `hincrbyfloat key field floatCounter`: hincrby 浮点数版本

### 列表类型

- 特点

```lua
  key              elements
user:1:message     a - b - c - d - e - f
                   > llen = 6
                   > lrange 2 3 -> c,d
                   > lindex 5 -> 5
                   > lrem 1 -> b
```

1. 有序
2. 可以重复
3. 左右两边插入弹出

- 重要 API： 以 L 开头

1. `rpush key value1 value2 ...valueN`[o(1 ~ n)]: 从列表右端插入值(1 ~ N 个)
2. `lpush key value1 value2 ...valueN`[o(1 ~ n)]: 从列表左端插入值(1 ~ N 个)

```sh
# a <- b <- c
lpush listkey c b a
```

3. `linsert key before|after value newValue` [o(n)] : 在 list 指定的值前|后插入 newValue
4. 删除 `lpop, rpop`
5. 删除 `lrem key count value`: 根据 count 值，从列表中删除所有 value 相等的项
   > count > 0, 从左到右，删除最多 count 个 value 相等的项；
   > count < 0, 从右到左，删除最多 Math.abs(count)个 value 相等的项；
   > count = 0, 删除所有 value 相等的项；
6. `ltrim key start end`: 按照索引范围，修剪（保留索引内的）列表
7. `lrange key start end(包含end)`: 获取列表指定索引范围所有 item
8. `lindex key index`
9. `llen key`: 获取列表长度
10. `lset key index newValue`:设置列表指定索引值为 newValue

- 实例

1. 微博 TimeLine:将您的所关注用户内容，按照时间排列

- 总结

11. `blpop key timeout`: lpop 阻塞版本，timeout 是阻塞超时时间，timeout=0,为永远不阻塞。
12. `brpop key timeout`: rpop 阻塞版本，timeout 是阻塞超时时间，timeout=0,为永远不阻塞。
13. TIPS
    > 1.  LPUSH + LPOP = Stack
    > 2.  LPUSH + RPOP = Queue
    > 3.  LPUSH + LTRIM = Capped Collection(固定列表)
    > 4.  LPUSH + BRPOP = Message Queue

### 集合类型

### 有序集合类型
