# 使用和设计

## 缓存的收益与成本

- 收益

1. 加速读写

   - 通过缓存加速读写速度： CPU L1/L2/L3 Cache, Linux page Cache 加速硬盘读写，浏览器缓存，Ehcache 缓存数据库等。

2. 降低后端负载

   - 后端服务器通过前端缓存降低负载： 业务端使用 Redis 降低后端 MySQL 负载等。

- 成本

1. 数据不一致： 缓存层和数据层有时间窗口不一致，和更新策略有关。
2. 代码维护成本： 多了一层缓存逻辑。
3. 运维成本： Redis Cluster

- 使用场景

1. 降低后端负载；
   - 对高消耗的 SQL: join 结果集、分组统计结果缓存。
2. 加速请求响应：
   - 利用 Redis/Memcache 优化 IO 响应时间。
3. 大量写合并为批量写：
   - 如计数器先 Redis 累加，再批量写 DB

## 缓存更新策略

## 缓存粒度控制

## 缓存穿透优化

- 缓存层，sql 层，数据都找不到

```lua
          request
    1 miss  | |- -|
          cache
    2 miss  |      |
          storage -

```

- 原因

1. 业务代码自身问题。
2. 恶意攻击，爬虫等等。

- 如何发现

1. 业务的响应时间
2. 业务本身问题
3. 相关指标： 总调用数，缓存层命中数，存储层命中数

- 解决方法 1：缓存空对象

```lua
          request
    1 miss  |   |-          -|
          cache
    2 miss  | | 3 cache null |
          storage - -

```

```java
public String getPassThrough(String key) {
    String cacheValue = cache.get(key);
    if(StringUtils.isBlank(cacheValue)) {
        String storageValue = storage.get(key);
        cache.set(key, storageValue);
        // 如果存储数据为空，需要设置一个过期时间（300s)
        if(StringUtils.isBlank(storageValue)) {
            cache.expire(key, 60*5)
        }
        return storageValue;
    } else {
        return cacheValue;
    }
}
```

- 解决方法 2： 布隆过滤器拦截

```lua
                request
    - - - - - - - - - - - - - - -
    2 miss/hit |    | 3 miss    ^
               |    |           |
            bloom filter        |
            - - - - - -         |
              cache             |
              |  ^              |
   1 Offline  |  | 4 hit        |
     storage
   - - - - - - - - - - - - - - -
            storage
```

## 无底洞问题优化

## 缓存雪崩优化

## 热点 key 重建优化
