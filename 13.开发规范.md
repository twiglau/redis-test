# 规范

## 键值设计

1. 可读性和可管理性
   - 以业务名（或数据库名）为前缀（防止 key 冲突），用冒号分隔，比如 业务名:表名:1, 如 ugc:video:1
2. 简洁性 user:{uid}:friends:messages:{mid} 简化： u:{uid}:fr:m:{mid}

## value 设计

- 杜绝 bigkey

1. string 类型控制的 10KB 以内
2. hash,list,set,zset 元素个数不要超过 5000

- bigkey 危害

1. 网络阻塞
2. 集群节点数据不均衡
3. Redis 阻塞

## bigkey

1. 应用方异常

```log
java.net.SocketTimeoutException: Read timed out
JedisConnectionException: Could not get a resource from the pool
```

```sh
# ps 显示系统进程信息
# a:显示所有终端上的进程，包括其他用户的进程
# u:以“用户化”格式显示（会有USER,PID,%CPU等列）
# x:包含没有控制端的集成（即后台、守护进程)
# | grep redis: 把 ps 的输出通过管道，传给 grep,只保留包含 redis 的行。
ps aux | grep redis
```

2. redis-cli --bigkeys
3. scan + debug object

```sh
redis-cli debug object diagnose:history:2937283:201804250300:201804250600
```

4. 主动报警： 网络流量监控， 客户端监控
5. 内核特点 key 问题优化以及工具
6. bigkey 删除
   > 1. 阻塞：注意隐形删除（过期，rename 等）
   > 2. Redis 4.0: lazy delete(unlink 命令)

```java
public void delBigHash(String host, int port, String password, String bigHashKey) {
    Jedis jedis = new Jedis(host, port);
    if(password != null && !"".equals(password)) {
        jedis.auth(password);
    }
    ScanParams scanParams = new ScanParams().count(100);
    String cursor = "0";
    do {
        ScanResult<Entry<String,String>> scanResult = jedis.hscan(bigHashKey,cursor,scanParams);
        List<Entry<String,String>> entryList = scanResult.getResult();
        if(entryList != null && !entryList.isEmpty()) {
            for(Entry<String,String> entry: entryList) {
                jedis.hdel(bigHashKey, entry.getKey());
            }
        }
        cursor = scanResult.getStringCursor();
    } while(!"0".equals(cursor));

    // 删除bigkey
    jedis.del(bigHashKey);
}
```

## 合理数据结构

- 实体类型 （数据结构内存优化： 例如 ziplist, 注意内存和性能的平衡）

1. 反例:

```sh
set user:1:name tom;
set user:1:age 19;
set user:1:favor football;
```

2. 正例:

```sh
hmset user:1 name tom age 19 favor football
```

- 一个例子，三种方案
  > 需求： picId => userId (100 万)

1. 全部 string: `set picId userId`
2. 一个 hash: `hset allPics picId userId`
3. 若干个小 hash: `hset picId/100 picId%100 userId`
4. 三种方案对比

```lua
方案            优点            缺点
全string      编程简单         浪费内存
                             全量获取较为复杂
全hash        暂无            浪费内存
                             bigkey
分段hash      节省内存         编程复杂
                             超时问题
                             性能问题 "ziplist"
```

## 键值声明周期管理

- Redis 不是垃圾桶

1.  周期数据需要设置过期时间， `object idle time` 可以找垃圾 key-value
2.  过期时间不宜集中： 缓存穿透和雪崩等问题。

## 命令优化技巧

1. 【推荐】O(N)以上命令关注 N 的数量

   > 例如：hgetall,lrange,smemebers,zrange,sinter 等并非不能使用，但是需要明确 N 的值。
   > 有遍历的需求，可以使用 hscan,sscan,zscan 代替。

2. 【推荐】禁用命令

   > 禁止线上使用 keys, flushall, flushdb 等，通过 redis 的 rename 机制禁掉命令，或者使用
   > scan 的方式渐进式处理。

3. 【推荐】合理使用 select

   > 1. redis 的多数据库较弱，使用数字进行区分
   > 2. 很多客户端支持较差
   > 3. 同时多业务用多数据库实际还是单线程处理，会有干扰

4. 【推荐】Redis 事务功能较弱，不建议过多使用

## 客户端优化

## 连接池优化
